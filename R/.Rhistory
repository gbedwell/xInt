seq.chars <- strsplit(seq, "")[[1]]
x.positions <- which(seq.chars == "X")
sample.barcode <- sample(c("A", "T", "G", "C"), length(x.positions), replace = TRUE)
seq.chars[x.positions] <- sample.barcode
return(seq = paste0(seq.chars, collapse = ""))
} else {
return(seq)
}
}
make_umis <- function(ltr.seq, linker.seq, seqs, ltr.has.umi, linker.has.umi){
n.seqs <- length(seqs)
ltr.chars <- strsplit(ltr.seq, "")[[1]]
ltr.n.positions <- which(ltr.chars == "N")
linker.chars <- strsplit(linker.seq, "")[[1]]
linker.n.positions <- which(linker.chars == "N")
if(ltr.has.umi){
ltr.umi.count <- length(ltr.n.positions) * n.seqs
all.ltr.umis <- sample(c("A", "T", "G", "C"), ltr.umi.count, replace = TRUE)
ltr.umi.matrix <- matrix(all.ltr.umis, nrow = n.seqs, ncol = length(ltr.n.positions))
}
if(linker.has.umi){
linker.umi.count <- length(linker.n.positions) * n.seqs
all.linker.umis <- sample(c("A", "T", "G", "C"), linker.umi.count, replace = TRUE)
linker.umi.matrix <- matrix(all.linker.umis, nrow = n.seqs, ncol = length(linker.n.positions))
}
all.seqs <- vapply(
X = seq_len(n.seqs),
FUN = function(x){
current.ltr <- ltr.chars
current.linker <- linker.chars
if(ltr.has.umi){
current.ltr[ltr.n.positions] <- ltr.umi.matrix[x,]
}
if(linker.has.umi){
current.linker[linker.n.positions] <- linker.umi.matrix[x,]
}
current.ltr.str <- paste0(current.ltr, collapse = "")
current.linker.str <- paste0(current.linker, collapse = "")
current.linker.rc <- as.character(reverseComplement(DNAString(current.linker.str)))
paste0(current.ltr.str, as.character(seqs[x]), current.linker.rc)
},
FUN.VALUE = character(1)
)
return(all.seqs)
}
trim_seqs <- function(fragments, min.width = 25, max.width = 1200, max.bp = 150,
ltr.seq, linker.seq, mismatch.prob = 0.0025, indel.prob = 2.5E-5,
decay.scale = 0.75, noise.scale = 3, offset = 33, as.fasta = FALSE){
if(missing(ltr.seq) || missing(linker.seq)){
stop("Both ltr.seq and linker.seq must be defined. Define as NULL if no LTR or linker sequences should be simulated.")
}
if((is.null(ltr.seq) && !is.null(linker.seq)) || (!is.null(ltr.seq) && is.null(linker.seq))){
stop("ltr.seq and linker.seq must both be NULL or not NULL.")
}
filtered <- fragments[width(fragments) >= min.width & width(fragments) <= max.width]
if(!is.null(ltr.seq) && !is.null(linker.seq)){
ltr.seq <- make_sample_barcodes(ltr.seq)
linker.seq <- make_sample_barcodes(linker.seq)
ltr.has.umi <- grepl("N", ltr.seq)
linker.has.umi <- grepl("N", linker.seq)
if(ltr.has.umi || linker.has.umi){
all.seqs <- make_umis(
ltr.seq = ltr.seq,
linker.seq = linker.seq,
seqs = filtered,
ltr.has.umi = ltr.has.umi,
linker.has.umi = linker.has.umi
)
appended <- DNAStringSet(all.seqs)
} else {
linker.rc <- as.character(reverseComplement(DNAString(linker.seq)))
appended <- DNAStringSet(paste0(ltr.seq, as.character(filtered), linker.rc))
}
} else{
appended <- filtered
}
left <- subseq(
x = appended,
start = 1,
width = pmin(width(appended), max.bp)
)
right <- subseq(
x = appended,
start = pmax(1, width(appended) - max.bp + 1),
width = pmin(width(appended), max.bp)
)
right <- reverseComplement(right)
if(mismatch.prob > 0 && indel.prob > 0){
r1.reads <- DNAStringSet(sapply(left, mutate_sequences, mismatch.prob, indel.prob, max.bp = max.bp))
r2.reads <- DNAStringSet(sapply(right, mutate_sequences, mismatch.prob, indel.prob, max.bp = max.bp))
} else{
r1.reads <- left
r2.reads <- right
}
names(r1.reads) <- paste0("fragment_", seq_along(r1.reads))
names(r2.reads) <- paste0("fragment_", seq_along(r2.reads))
if(!isTRUE(as.fasta)){
r1.scores <- vapply(
X = width(r1.reads),
FUN = generate_quality_scores,
FUN.VALUE = character(1),
decay.scale = decay.scale,
noise.scale = noise.scale,
as.phred = TRUE,
as.ASCII = TRUE,
offset = offset,
max.bp = max.bp
)
r2.scores <- vapply(
X = width(r2.reads),
FUN = generate_quality_scores,
FUN.VALUE = character(1),
decay.scale = decay.scale,
noise.scale = noise.scale,
as.phred = TRUE,
as.ASCII = TRUE,
offset = offset,
max.bp = max.bp
)
return(
list(
R1 = list(seq = as.character(r1.reads), qual = r1.scores),
R2 = list(seq = as.character(r2.reads), qual = r2.scores)
)
)
} else{
return(
list(
R1 = as.character(r1.reads),
R2 = as.character(r2.reads)
)
)
}
}
trimmed <- trim_seqs(
fragments = seqs,
ltr.seq = "XXXXXATGCATGCATGCATGCNNNNN",
linker.seq = "XXXXXATGCATGCATGCATGCNNNNN",
max.bp = 200
)
#' Generate Quality Scores
#'
#' Generate quality scores for simulated NGS reads.
#' The scores roughly approximate the quality score trends seen in real NGS experiments.
#'
#'@param read.length The length of the sequence for which scores are being generated.
#'@param decay.scale Determines the decay rate of the quality scores. Defaults to 0.75.
#'@param noise.scale The amount of noise to add to the quality scores. Defaults to 3.
#'@param as.phred Boolean. Whether or not to return Phred scores. Defaults to TRUE.
#'If FALSE, error probabilities are returned.
#'@param as.ASCII Boolean. Whether or not to return the Phred scores as ASCII characters.
#'Defaults to TRUE.
#'@param offset The ASCII offset of the quality scores. Defaults to 33.
#'@param max.bp The maximum read length. Defaults to 150 bp.
#'
#'@return A vector of quality scores
#'
generate_quality_scores <- function(
read.length,
decay.scale = 0.7,
noise.scale = 5,
as.phred = TRUE,
as.ASCII = TRUE,
offset = 33,
max.bp = 150
) {
start.phred <- sample(x = seq(36,41), size = 1,
prob = c(0.05, 0.1, 0.25, 0.4, 0.15, 0.05))
base.prob <- 10^(-start.phred / 10)
early.cutoff <- floor(max.bp * runif(1, (1 / (max.bp / 2)), (1 / (max.bp / 2) * 10)))
error.probs <- vapply(
X = 1:max.bp,
FUN = function(pos) {
denom <- sample(x = seq(25, 125, 25), size = 1,
prob = c(0.05, 0.15, 0.25, 0.3, 0.25))
rise.pos <- if(pos <= early.cutoff) exp((early.cutoff - pos) / denom) else 1
decay.pos <- decay.scale * (pos / max.bp)
decay.prob <- base.prob * exp(0.2 * decay.pos + 4.5 * decay.pos^3)
phred.ratio <- (-10 * log10(decay.prob) / start.phred)
dynamic.noise <- noise.scale * (1 - phred.ratio)
all.scores <- decay.prob * rise.pos * exp(rnorm(1, mean = 0, sd = dynamic.noise))
return(all.scores)
},
FUN.VALUE = numeric(1)
)
if(as.phred) {
qualities <- round(-10 * log10(error.probs))
qualities <- pmin(pmax(qualities, 0), 42)
if(qualities[1] == 31){
qualities[1] <- 32 # Make sure the quality score line doesn't start with @.
}
if(as.ASCII){
return(rawToChar(as.raw(qualities + offset)))
}
return(qualities)
}
return(error.probs)
}
trimmed <- trim_seqs(
fragments = seqs,
ltr.seq = "XXXXXATGCATGCATGCATGCNNNNN",
linker.seq = "XXXXXATGCATGCATGCATGCNNNNN",
max.bp = 200
)
#' Generate Quality Scores
#'
#' Generate quality scores for simulated NGS reads.
#' The scores roughly approximate the quality score trends seen in real NGS experiments.
#'
#'@param read.length The length of the sequence for which scores are being generated.
#'@param decay.scale Determines the decay rate of the quality scores. Defaults to 0.75.
#'@param noise.scale The amount of noise to add to the quality scores. Defaults to 3.
#'@param as.phred Boolean. Whether or not to return Phred scores. Defaults to TRUE.
#'If FALSE, error probabilities are returned.
#'@param as.ASCII Boolean. Whether or not to return the Phred scores as ASCII characters.
#'Defaults to TRUE.
#'@param offset The ASCII offset of the quality scores. Defaults to 33.
#'@param max.bp The maximum read length. Defaults to 150 bp.
#'
#'@return A vector of quality scores
#'
generate_quality_scores <- function(
read.length,
decay.scale = 0.7,
noise.scale = 5,
as.phred = TRUE,
as.ASCII = TRUE,
offset = 33,
max.bp = 150
) {
start.phred <- sample(x = seq(36,41), size = 1,
prob = c(0.05, 0.1, 0.25, 0.4, 0.15, 0.05))
base.prob <- 10^(-start.phred / 10)
early.cutoff <- floor(max.bp * runif(1, (1 / (max.bp / 2)), (1 / (max.bp / 2) * 10)))
error.probs <- vapply(
X = 1:max.bp,
FUN = function(pos) {
denom <- sample(x = seq(25, 125, 25), size = 1,
prob = c(0.05, 0.15, 0.25, 0.3, 0.25))
rise.pos <- if(pos <= early.cutoff) exp((early.cutoff - pos) / denom) else 1
decay.pos <- decay.scale * (pos / max.bp)
decay.prob <- base.prob * exp(0.2 * decay.pos + 4.5 * decay.pos^3)
phred.ratio <- (-10 * log10(decay.prob) / start.phred)
dynamic.noise <- noise.scale * (1 - phred.ratio)
all.scores <- decay.prob * rise.pos * exp(rnorm(1, mean = 0, sd = dynamic.noise))
return(all.scores)
},
FUN.VALUE = numeric(1)
)
error.probs <- error.probs[1:min(read.length, max.bp)]
if(as.phred) {
qualities <- round(-10 * log10(error.probs))
qualities <- pmin(pmax(qualities, 0), 42)
if(qualities[1] == 31){
qualities[1] <- 32 # Make sure the quality score line doesn't start with @.
}
if(as.ASCII){
return(rawToChar(as.raw(qualities + offset)))
}
return(qualities)
}
return(error.probs)
}
trimmed <- trim_seqs(
fragments = seqs,
ltr.seq = "XXXXXATGCATGCATGCATGCNNNNN",
linker.seq = "XXXXXATGCATGCATGCATGCNNNNN",
max.bp = 200
)
width(seqs)
library(Biostrings)
library(GenomicRanges)
bases <- c("A", "T", "G", "C")
n <- 1000
length.seqs <- 100
seqs <- replicate(n, paste0(sample(bases, length.seqs, replace = TRUE), collapse=""))
seqs <- DNAStringSet(seqs)
trimmed <- trim_seqs(
fragments = seqs,
ltr.seq = "XXXXXATGCATGCATGCATGCNNNNN",
linker.seq = "XXXXXATGCATGCATGCATGCNNNNN",
max.bp = 100
)
save_fastq(
reads = trimmed,
directory.path = "~/Desktop",
prefix = "test",
paired = TRUE,
compress = TRUE
)
trimmed2 <- trim_seqs(
fragments = seqs,
ltr.seq = NULL,
linker.seq = NULL,
max.bp = 100
)
save_fasta(
reads = trimmed2,
directory.path = "~/Desktop",
prefix = "test",
paired = TRUE,
compress = TRUE
)
trimmed2
names(trimmed2)
trimmed2[[1]]
trimmed2 <- trim_seqs(
fragments = seqs,
ltr.seq = NULL,
linker.seq = NULL,
max.bp = 100,
as.fasta = TRUE
)
save_fasta(
reads = trimmed2,
directory.path = "~/Desktop",
prefix = "test",
paired = TRUE,
compress = TRUE
)
trimmed2
#' Trim Fragments
#'
#' Trim the generated random fragments to simulate sequencing reads.
#' Creates paired end fragments of a defined maximum read size and with a defined maximum inner distance.
#'
#'@param fragments The DNAStringSet object containing the random fragment sequences.
#'@param min.width The minimum acceptable fragment length (insert size). Defaults to 25.
#'@param max.width The maximum acceptable fragment length (insert size). Defaults to 1200.
#'@param max.bp The maximum read length. Defaults to 150 bp.
#'@param ltr.seq The LTR sequence sequenced in the experiment, given in the 5' to 3' orientation.
#' Should be a character string. Use 'X' for sample-specific barcodes, 'N' for unique per-sequence barcodes.
#'@param linker.seq The linker sequence sequenced in the experiment, given in the 5' to 3' orientation.
#' Should be a character string. Use 'X' for sample-specific barcodes, 'N' for unique per-sequence barcodes.
#'@param mismatch.prob The mismatch rate. Defaults to 0.0025.
#'@param indel.prob The indel rate. Defaults to 2.5E-5.
#'@param decay.scale Determines the decay rate of the quality scores. Defaults to 0.75.
#'@param noise.scale The amount of noise to add to the quality scores. Defaults to 3.
#'@param offset The ASCII offset of the quality scores. Defaults to 33.
#'
#'@return A list containing simulated R1 and R2 reads.
#'
#'@import GenomicRanges
#'@import Biostrings
#'
make_sample_barcodes <- function(seq){
if (grepl("X", seq)) {
seq.chars <- strsplit(seq, "")[[1]]
x.positions <- which(seq.chars == "X")
sample.barcode <- sample(c("A", "T", "G", "C"), length(x.positions), replace = TRUE)
seq.chars[x.positions] <- sample.barcode
return(seq = paste0(seq.chars, collapse = ""))
} else {
return(seq)
}
}
make_umis <- function(ltr.seq, linker.seq, seqs, ltr.has.umi, linker.has.umi){
n.seqs <- length(seqs)
ltr.chars <- strsplit(ltr.seq, "")[[1]]
ltr.n.positions <- which(ltr.chars == "N")
linker.chars <- strsplit(linker.seq, "")[[1]]
linker.n.positions <- which(linker.chars == "N")
if(ltr.has.umi){
ltr.umi.count <- length(ltr.n.positions) * n.seqs
all.ltr.umis <- sample(c("A", "T", "G", "C"), ltr.umi.count, replace = TRUE)
ltr.umi.matrix <- matrix(all.ltr.umis, nrow = n.seqs, ncol = length(ltr.n.positions))
}
if(linker.has.umi){
linker.umi.count <- length(linker.n.positions) * n.seqs
all.linker.umis <- sample(c("A", "T", "G", "C"), linker.umi.count, replace = TRUE)
linker.umi.matrix <- matrix(all.linker.umis, nrow = n.seqs, ncol = length(linker.n.positions))
}
all.seqs <- vapply(
X = seq_len(n.seqs),
FUN = function(x){
current.ltr <- ltr.chars
current.linker <- linker.chars
if(ltr.has.umi){
current.ltr[ltr.n.positions] <- ltr.umi.matrix[x,]
}
if(linker.has.umi){
current.linker[linker.n.positions] <- linker.umi.matrix[x,]
}
current.ltr.str <- paste0(current.ltr, collapse = "")
current.linker.str <- paste0(current.linker, collapse = "")
current.linker.rc <- as.character(reverseComplement(DNAString(current.linker.str)))
paste0(current.ltr.str, as.character(seqs[x]), current.linker.rc)
},
FUN.VALUE = character(1)
)
return(all.seqs)
}
trim_seqs <- function(fragments, min.width = 25, max.width = 1200, max.bp = 150,
ltr.seq, linker.seq, mismatch.prob = 0.0025, indel.prob = 2.5E-5,
decay.scale = 0.75, noise.scale = 3, offset = 33, as.fasta = FALSE){
if(missing(ltr.seq) || missing(linker.seq)){
stop("Both ltr.seq and linker.seq must be defined. Define as NULL if no LTR or linker sequences should be simulated.")
}
if((is.null(ltr.seq) && !is.null(linker.seq)) || (!is.null(ltr.seq) && is.null(linker.seq))){
stop("ltr.seq and linker.seq must both be NULL or not NULL.")
}
filtered <- fragments[width(fragments) >= min.width & width(fragments) <= max.width]
if(!is.null(ltr.seq) && !is.null(linker.seq)){
ltr.seq <- make_sample_barcodes(ltr.seq)
linker.seq <- make_sample_barcodes(linker.seq)
ltr.has.umi <- grepl("N", ltr.seq)
linker.has.umi <- grepl("N", linker.seq)
if(ltr.has.umi || linker.has.umi){
all.seqs <- make_umis(
ltr.seq = ltr.seq,
linker.seq = linker.seq,
seqs = filtered,
ltr.has.umi = ltr.has.umi,
linker.has.umi = linker.has.umi
)
appended <- DNAStringSet(all.seqs)
} else {
linker.rc <- as.character(reverseComplement(DNAString(linker.seq)))
appended <- DNAStringSet(paste0(ltr.seq, as.character(filtered), linker.rc))
}
} else{
appended <- filtered
}
left <- subseq(
x = appended,
start = 1,
width = pmin(width(appended), max.bp)
)
right <- subseq(
x = appended,
start = pmax(1, width(appended) - max.bp + 1),
width = pmin(width(appended), max.bp)
)
right <- reverseComplement(right)
if(mismatch.prob > 0 && indel.prob > 0){
r1.reads <- DNAStringSet(sapply(left, mutate_sequences, mismatch.prob, indel.prob, max.bp = max.bp))
r2.reads <- DNAStringSet(sapply(right, mutate_sequences, mismatch.prob, indel.prob, max.bp = max.bp))
} else{
r1.reads <- left
r2.reads <- right
}
names(r1.reads) <- paste0("fragment_", seq_along(r1.reads))
names(r2.reads) <- paste0("fragment_", seq_along(r2.reads))
if(!isTRUE(as.fasta)){
r1.scores <- vapply(
X = width(r1.reads),
FUN = generate_quality_scores,
FUN.VALUE = character(1),
decay.scale = decay.scale,
noise.scale = noise.scale,
as.phred = TRUE,
as.ASCII = TRUE,
offset = offset,
max.bp = max.bp
)
r2.scores <- vapply(
X = width(r2.reads),
FUN = generate_quality_scores,
FUN.VALUE = character(1),
decay.scale = decay.scale,
noise.scale = noise.scale,
as.phred = TRUE,
as.ASCII = TRUE,
offset = offset,
max.bp = max.bp
)
return(
list(
R1 = list(seq = as.character(r1.reads), qual = r1.scores),
R2 = list(seq = as.character(r2.reads), qual = r2.scores)
)
)
} else{
return(
list(
R1 = r1.reads,
R2 = r2.reads
)
)
}
}
trimmed2 <- trim_seqs(
fragments = seqs,
ltr.seq = NULL,
linker.seq = NULL,
max.bp = 100,
as.fasta = TRUE
)
save_fasta(
reads = trimmed2,
directory.path = "~/Desktop",
prefix = "test",
paired = TRUE,
compress = TRUE
)
seqs
seq_along(seqs)
library(BSgenome.Hsapiens.UCSC.hs1)
seqleves(Hsapiens)
seqlevels(Hsapiens)
DNAString(Hsapiens[[chr1]])
getSeq(Hsapiens, names=names(Hsapiens))
chr.seqs <- getSeq(Hsapiens, names=names(Hsapiens))
chr.seqs[["chr1"]]
chr.seqs['chr1']
for.pattern <- "TTAA"
for.pattern <- DNAStringSet("TTAA", use.names = TRUE)
rev.pattern <- complement(DNAStringSet("TTAA", use.names=TRUE))
for.pattern
rev.pattern
for.pos <- matchPDict(for.pattern, chr.seqs[["chrM"]])
for.pos
